
user  nginx;
worker_processes  1;

error_log  /var/log/nginx/error.log warn;
pid        /var/run/nginx.pid;

events {
    worker_connections  1024;
}

http {
  include       /etc/nginx/mime.types;
  default_type  application/octet-stream;
  #underscores_in_headers on;
  log_format  main  '$remote_addr - $remote_user [$time_local] "$request" '
                    '$status $body_bytes_sent "$http_referer" '
                    '"$http_user_agent" "$http_x_forwarded_for"';

  access_log  /var/log/nginx/access.log  main;

  sendfile        on;
  #tcp_nopush     on;
  proxy_http_version 1.1;
  proxy_set_header Connection "";
  keepalive_timeout  65;
  gzip  on;

  include /etc/nginx/conf.d/*.conf;
  server {
    listen 80 default_server;

    # Because we are connecting to downstream Docker services, any services that start after this one
    # will not have resolvable names, causing this nginx container not to start. Setting the hostname
    # as a variable is a workaround for this problem and should be done for all downstream containers.
    # We also need to define a resolver or the variables cannot be set. For this we can use the internal
    # Docker IP 127.0.0.11.

    resolver 127.0.0.11 valid=30s;
    set $jupyterhub jupyterhub;

    location / {
        proxy_set_header Host            $host;
        proxy_set_header X-Forwarded-For $remote_addr;
        proxy_set_header REMOTE_USER jptest;
        proxy_pass http://$jupyterhub:8000;
 
    }

    # location ~* /jupyter/(api/kernels/[^/]+/(channels|iopub|shell|stdin)|terminals/websocket)/? {
    #       proxy_pass http://$jupyterhub:8000;

    #     proxy_set_header Host            $host;
    #     proxy_set_header X-Forwarded-For $remote_addr;

    #       proxy_http_version 1.1;
    #       proxy_set_header Upgrade 'websocket';
    #       proxy_set_header Connection "upgrade";
    #       proxy_set_header Origin "";
    # }

  }
}
